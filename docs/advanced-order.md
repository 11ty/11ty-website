---
eleventyNavigation:
  key: Order of Operations
  parent: Advanced
  excerpt: How Eleventy works internally.
  order: 1
excludeFromSidebar: true
layout: "layouts/docs.njk"
---
# Order of Operations

From a very high level, Eleventy’s internal order of operations is such:

1. Find any file matching a valid Eleventy file extension in the Input directory. (e.g. `./src/**.njk` or `./docs/**.md`)
1. Iterate over the files.
	1. If it doesn’t match a template file extension, treat it as a [passthrough copy](/docs/copy/).
	1. If it does match a template file extension, continue processing as an Eleventy template.
1. Start the asynchronous copy of [passthrough copy](/docs/copy/). Both configuration specified passthrough copy and non-template-matching file extension files. This will continue while templates are being processed.
1. Initial [Data Cascade](/docs/data-cascade/) is generated for each template file. This includes all values from front matter, layouts, directory and file data files, global data.
	* The data cascade does **not** yet include populated `collections`, `templateContent`, or computed `page` values like `page.url` and `page.outputPath`. <!-- Template.js -> getTemplateMapEntries -->
1. Dependency graph is created of the templates to process them in the correct order. <!-- TemplateMap.js -->
	* This is a bit oversimplified (and some may mix and match if they aren’t dependent on each other) but from a high level the templates are processed like this (listed here in _reverse order_—`1` is processed first):
		<ol reversed>
			<li>Templates that use Pagination and target <code>collections.all</code></li>
			<li>Templates that use Pagination and target <code>collections</code></li>
			<li>Templates that use Pagination and target a Configuration API added collection</li>
			<li>Templates that use Pagination and target any other Collection (those supplied via <code>tags</code>)</li>
			<li>Templates that have <code>tags</code> specified</li>
			<li>Templates that have no dependencies or are <code>eleventyExcludeFromCollections</code></li>
		</ol>
	* _Note_: Eleventy does not automatically know what data is used inside of the template content at this stage. We use the specified front matter to know which templates supply collections and which templates consume collections. For a safety net we may [add a front matter option to declare dependencies manually](https://github.com/11ty/eleventy/issues/975).
1. [Collections](/docs/collections/) are generated in the correct order, per the dependency graph.
1. Additional [Data Cascade](/docs/data-cascade/) operations are applied: <!-- Template.js -> getTemplates -->
	* A separate dependency graph is generated to populate [Computed Data](/docs/data-computed/), [`permalink`](/docs/permalinks/), [`page.url`](/docs/data-eleventy-supplied/), and [`page.outputPath`](/docs/data-eleventy-supplied/) in the correct order.
	* `renderData` (An undocumented and deprecated feature—use [Computed Data](/docs/data-computed/) instead!) is generated.
1. Templates are rendered in the order generated by the dependency graph (`templateContent` is generated) **without layouts** applied.
	1. Per the above _Note_ if a template uses another template’s `templateContent` before it has been generated, we defer this template to render in a second pass.
	1. After all `templateContent`’s have been rendered, they are copied into the appropriate collections’ objects. Remember that `templateContent` in collections does not have layouts included.
1. Eleventy checks for duplicate [permalinks](/docs/permalinks/) and throws an error if multiple templates are attempting to write to the same output file.
1. Templates are then rendered **with layouts** applied. The previously generated `templateContent` values (without layouts) are re-used here. This content is then written to files on disk.
